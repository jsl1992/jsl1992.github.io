{"posts":[{"title":"【版本号比较工具-（算法版）】","text":"1.版本号工具之前在网上看到版本号工具，觉得还行，就一直用这个。代码如下，写的也挺简洁的 123456789101112131415161718192021public static int compareAppVersion(String version1, String version2) { if (version1 == null || version2 == null) { throw new RuntimeException(&quot;版本号不能为空&quot;); } // 注意此处为正则匹配，不能用. String[] versionArray1 = version1.split(&quot;\\\\.&quot;); String[] versionArray2 = version2.split(&quot;\\\\.&quot;); int idx = 0; // 取数组最小长度值 int minLength = Math.min(versionArray1.length, versionArray2.length); int diff = 0; // 先比较长度，再比较字符 while (idx &lt; minLength &amp;&amp; (diff = versionArray1[idx].length() - versionArray2[idx].length()) == 0 &amp;&amp; (diff = versionArray1[idx].compareTo(versionArray2[idx])) == 0) { ++idx; } // 如果已经分出大小，则直接返回，如果未分出大小，则再比较位数，有子版本的为大 diff = (diff != 0) ? diff : versionArray1.length - versionArray2.length; return diff;} 2.算法版本不过最近发现，leetcode大神们写的算法，比较版本号。真的是简洁优雅高效，而且逻辑上更加完善。这边版本号是（忽略任何前导零后的整数值 例如1.01和1.001是一样的）。而且没有对string进行转换成数组，整体运行时间和空间都更佳。真正的简洁、优雅高效 1234567891011121314151617181920212223public int compareVersion(String version1, String version2) { if (version1 == null || version2 == null) { throw new RuntimeException(&quot;版本号不能为空&quot;); } int i = 0, j = 0; int n = version1.length(), m = version2.length(); while (i &lt; n || j &lt; m) { int a = 0; for (; i &lt; n &amp;&amp; version1.charAt(i) != '.'; i++) { a = a * 10 + version1.charAt(i) - '0'; } i++; int b = 0; for (; j &lt; m &amp;&amp; version2.charAt(j) != '.'; j++) { b = b * 10 + version2.charAt(j) - '0'; } j++; if (a != b) { return a &gt; b ? 1 : -1; } } return 0;} 3.结论看了大神们写的代码，发现和人的差距太大了。算法真的太神奇了。","link":"/2023/11/14/%E3%80%90%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7-%EF%BC%88%E7%AE%97%E6%B3%95%E7%89%88%EF%BC%89%E3%80%91/"},{"title":"统一支付接口，无限扩展不同支付服务工具包实现。【开箱即用】（可用于生产环境中）","text":"前言在实际生产环境中，我们经常面临多个支付厂商的选择和变更，这可能导致支付代码的不断修改和维护。为了更好地应对产品需求的变化，我们采用了策略模式，通过统一的支付接口将各个支付服务进行实现。这样一来，支付厂商的变化对业务代码没有任何影响，使得我们能够更灵活地应对支付服务的变化和新增，而无需频繁修改核心业务逻辑。这种设计不仅提高了代码的可维护性，还为未来的扩展和变更提供了便利。 实现方案支付 PayService(统一的支付Service方便将来扩展)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.github.ji.service;import com.github.ji.dto.PayDTO;import com.github.ji.dto.RefundDTO;import com.github.ji.enums.PayCode;import com.github.ji.vo.PayVO;/** * 支付 PayService(统一的支付Service方便将来扩展) * * @author jishenglong on 2023/3/27 10:02 **/public interface PayService { PayCode getPayCode(); /** * 支付 * * @param payDTO payDTO * @return com.github.ji.vo.PayVO * @author jisl on 2023/11/16 11:18 **/ PayVO pay(PayDTO payDTO); /** * 交易是否成功 * * @param merchantId 门店id * @param outTradeNo 交易订单号 * @param payAmount 支付金额 */ Boolean isPaySuccess(Integer merchantId, String outTradeNo, Integer payAmount); /** * 退款 * * @param refundDTO RefundDTO * @author jishenglong on 2023/4/19 15:23 **/ void refund(RefundDTO refundDTO); /** * 退款是否成功 * * @param outRefundNo 退款单号 * @param refundAmount 退款金额 */ Boolean isRefundSuccess(Integer merchantId, String outRefundNo, Integer refundAmount); /** * 关闭订单 * * @param outTradeNo 交易订单号 */ void payClose(Integer merchantId, String outTradeNo);} 微信支付抽象类引入抽象类是为了更好地封装微信支付的退款 SDK，尤其是在不同的微信支付方式下，调用方式保持一致。通过这一抽象，我们能够将共同的退款操作逻辑集中到一个代码库中，从而降低了具体实现类的重复程度。这种设计不仅提高了代码的重用性，也使得对微信支付退款的变更更为集中和方便。通过抽象类，我们有效地管理了微信支付的共享代码，简化了具体实现类的维护工作，确保了系统的一致性和可维护性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.github.ji.service.impl;import com.github.ji.config.MerchantMatchWeChatConfig;import com.github.ji.config.WxPayProperties;import com.github.ji.dto.RefundDTO;import com.github.ji.service.PayService;import com.wechat.pay.java.service.refund.RefundService;import com.wechat.pay.java.service.refund.model.*;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.util.Objects;/** * 微信支付抽象类（退款是相同的sdk放在这里） * * @author jishenglong on 2023/3/27 10:02 **/@Component@Slf4jpublic abstract class WeChatPayService implements PayService { @Resource private MerchantMatchWeChatConfig matchWeChatConfig; @Resource private WxPayProperties wxPayProperties; @Override public void refund(RefundDTO refundDTO) { final RefundService refundService = new RefundService.Builder().config(matchWeChatConfig.getCertificateConfig(refundDTO.getMerchantId())).build(); CreateRequest request = new CreateRequest(); request.setOutTradeNo(refundDTO.getOutTradeNo()); request.setOutRefundNo(refundDTO.getOutRefundNo()); request.setNotifyUrl(wxPayProperties.getDomainUrl() + &quot;/payNotify/weChatPay/refundOrder/&quot; + refundDTO.getMerchantId()); final AmountReq amountReq = new AmountReq(); amountReq.setRefund(Long.valueOf(refundDTO.getRefundAmount())); amountReq.setTotal(Long.valueOf(refundDTO.getAmount())); amountReq.setCurrency(&quot;CNY&quot;); request.setAmount(amountReq); refundService.create(request); } @Override public Boolean isRefundSuccess(Integer merchantId, String outRefundNo, Integer refundAmount) { final RefundService refundService = new RefundService.Builder().config(matchWeChatConfig.getCertificateConfig(merchantId)).build(); QueryByOutRefundNoRequest request = new QueryByOutRefundNoRequest(); request.setOutRefundNo(outRefundNo); final Refund refund = refundService.queryByOutRefundNo(request); return Objects.equals(refund.getStatus(), Status.SUCCESS) &amp;&amp; Objects.equals(refund.getAmount().getRefund().intValue(), refundAmount); }} 支付厂商实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.github.ji.service.impl;import com.github.ji.config.MerchantMatchWeChatConfig;import com.github.ji.config.WxPayProperties;import com.github.ji.dto.PayDTO;import com.github.ji.enums.PayCode;import com.github.ji.service.IMerchantMatchService;import com.github.ji.vo.MerchantMatchVO;import com.github.ji.vo.PayVO;import com.wechat.pay.java.core.RSAAutoCertificateConfig;import com.wechat.pay.java.core.util.NonceUtil;import com.wechat.pay.java.service.payments.app.AppService;import com.wechat.pay.java.service.payments.app.model.Amount;import com.wechat.pay.java.service.payments.app.model.CloseOrderRequest;import com.wechat.pay.java.service.payments.app.model.PrepayRequest;import com.wechat.pay.java.service.payments.app.model.QueryOrderByOutTradeNoRequest;import com.wechat.pay.java.service.payments.model.Transaction;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.Resource;import java.time.Instant;import java.util.Objects;/** * 微信APP支付服务实现 * * @author jishenglong on 2023/3/27 10:02 **/@Component@Slf4jpublic class WeChatAppPayServiceImpl extends WeChatPayService { @Resource private MerchantMatchWeChatConfig matchWeChatConfig; @Resource private IMerchantMatchService merchantMatchService; @Resource private WxPayProperties wxPayProperties; @Override public PayCode getPayCode() { return PayCode.WX_APP; } @Override public PayVO pay(PayDTO payDTO) { final MerchantMatchVO merchantMatchVO = merchantMatchService.selectByMerchantId(payDTO.getMerchantId()); final RSAAutoCertificateConfig certificateConfig = matchWeChatConfig.getCertificateConfig(merchantMatchVO); PrepayRequest request = new PrepayRequest(); Amount amount = new Amount(); amount.setTotal(payDTO.getAmount()); request.setAmount(amount); request.setAppid(wxPayProperties.getAppid()); request.setMchid(merchantMatchVO.getMchId()); request.setDescription(payDTO.getDescription()); request.setNotifyUrl(wxPayProperties.getDomainUrl() + &quot;/payNotify/weChatPay/notifyOrder/&quot; + payDTO.getMerchantId()); request.setOutTradeNo(payDTO.getOutTradeNo()); String prepayId = getAppService(payDTO.getMerchantId()).prepay(request).getPrepayId(); long timestamp = Instant.now().getEpochSecond(); String nonceStr = NonceUtil.createNonce(32); String message = request.getAppid() + &quot;\\n&quot; + timestamp + &quot;\\n&quot; + nonceStr + &quot;\\n&quot; + prepayId + &quot;\\n&quot;; log.debug(&quot;Message for RequestPayment signatures is[{}]&quot;, message); String sign = certificateConfig.createSigner().sign(message).getSign(); PayVO response = new PayVO(); response.setAppid(request.getAppid()); response.setPartnerId(request.getMchid()); response.setPrepayId(prepayId); response.setPackageVal(&quot;Sign=WXPay&quot;); response.setNonceStr(nonceStr); response.setTimestamp(String.valueOf(timestamp)); response.setPaySign(sign); return response; } private AppService getAppService(Integer merchantId) { return new AppService.Builder().config(matchWeChatConfig.getCertificateConfig(merchantId)).build(); } @Override public Boolean isPaySuccess(Integer merchantId, String outTradeNo, Integer payAmount) { final QueryOrderByOutTradeNoRequest request = new QueryOrderByOutTradeNoRequest(); request.setMchid(merchantMatchService.selectByMerchantId(merchantId).getMchId()); request.setOutTradeNo(outTradeNo); final Transaction transaction = getAppService(merchantId).queryOrderByOutTradeNo(request); return Objects.equals(transaction.getTradeState(), Transaction.TradeStateEnum.SUCCESS) &amp;&amp; Objects.equals(transaction.getAmount().getTotal(), payAmount); } @Override public void payClose(Integer merchantId, String outTradeNo) { final CloseOrderRequest request = new CloseOrderRequest(); request.setMchid(merchantMatchService.selectByMerchantId(merchantId).getMchId()); request.setOutTradeNo(outTradeNo); getAppService(merchantId).closeOrder(request); }} PayContext通过创建 PayContext，我们成功将所有支付实现类汇聚到一个中心化的管理器中。这种设计使得支付方式的选择和切换变得更为简洁和方便。业务代码只需与 PayContext 进行交互，而无需直接与具体的支付实现类打交道。这不仅提高了代码的可读性，也使得系统更易于维护和扩展。通过 PayContext，我们实现了一种灵活且高度可扩展的支付体系，使得系统能够轻松适应支付方式的变化，同时确保业务逻辑的清晰和解耦 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.github.ji;import com.github.ji.service.PayService;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.util.List;import java.util.Map;import java.util.function.Function;import java.util.stream.Collectors;/** * 支付方式的PayContext，自动加入到这个PayContext */@Slf4j@Componentpublic class PayContext { private Map&lt;Integer, PayService&gt; payServiceMap; // spring中，在使用@Autowired注解注入list集合的时候，并不会根据List类型去容器中查找，而是根据list集合的元素类型，从spring容器中找到所有的实现类，放在list集合中，然后注入到bean中 @Resource private List&lt;PayService&gt; payServiceList; @PostConstruct public void buildMap() {// 将来完善下，可以加入是否禁用等 payServiceMap = payServiceList.stream() .collect(Collectors.toMap(operationStrategy -&gt; operationStrategy.getPayCode().getCode(), Function.identity())); } public PayService getPayService(Integer code) { if (!payServiceMap.containsKey(code)) { throw new RuntimeException(&quot;没有该支付方式&quot;); } return payServiceMap.get(code); }} 支付调用通过使用 PayCode 来选择支付方式，我们实现了对不同支付厂商的调用，从而将支付的变化抽象到了一个统一的接口中。这种设计使得业务代码与支付实现之间完全解耦，业务逻辑无需关心具体的支付厂商，只需通过 PayCode 来选择支付方式即可。这不仅提高了代码的可扩展性，使得支付方式的变化对业务代码没有任何影响，而且使系统更容易适应未来的扩展和变更。这种解耦的设计方式为我们提供了更大的灵活性和可维护性，确保了系统的健壮性。 12345678910111213@ApiOperation(&quot;订单支付&quot;)@PostMapping(&quot;/orderPay&quot;)public CommonResult&lt;PayVO&gt; orderPay(@Validated @RequestBody OrderPayDTO orderDTO) { final PayService payService = payContext.getPayService(orderDTO.getPayCode()); Order order = new Order(); final PayDTO payDTO = PayDTO.builder() .description(order.getDescription()).outTradeNo(order.getOutTradeNo()) .openid(orderDTO.getOpenid()).amount(order.getAmount()) .payCode(orderDTO.getPayCode()).merchantId(order.getMerchantId()) .build(); final PayVO payVO = payService.pay(payDTO); return CommonResult.success(payVO);} GitHub源码源码获取:JCommon 总结通过策略的封装，我们成功将支付功能解耦，摆脱了硬编码的束缚。这意味着不再需要为产品的每一个支付需求而硬编码，从而大大提高了系统的灵活性。现在，我们可以通过简单地切换策略，适应产品支付方式的变化，而不必担心影响到业务代码。这种解耦的设计使得支付模块更为可维护和可扩展，为未来的需求变更提供了更为便捷的途径","link":"/2023/11/16/%E7%BB%9F%E4%B8%80%E6%94%AF%E4%BB%98%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%97%A0%E9%99%90%E6%89%A9%E5%B1%95%E4%B8%8D%E5%90%8C%E6%94%AF%E4%BB%98%E6%9C%8D%E5%8A%A1%E5%B7%A5%E5%85%B7%E5%8C%85%E5%AE%9E%E7%8E%B0%E3%80%82%E3%80%90%E5%BC%80%E7%AE%B1%E5%8D%B3%E7%94%A8%E3%80%91%EF%BC%88%E5%8F%AF%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%89/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}],"pages":[]}