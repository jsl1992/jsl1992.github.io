{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/11/14/hello-world/"},{"title":"【版本号比较工具-（算法版）】","text":"1.版本号工具之前在网上看到版本号工具，觉得还行，就一直用这个。代码如下，写的也挺简洁的 123456789101112131415161718192021public static int compareAppVersion(String version1, String version2) { if (version1 == null || version2 == null) { throw new RuntimeException(&quot;版本号不能为空&quot;); } // 注意此处为正则匹配，不能用. String[] versionArray1 = version1.split(&quot;\\\\.&quot;); String[] versionArray2 = version2.split(&quot;\\\\.&quot;); int idx = 0; // 取数组最小长度值 int minLength = Math.min(versionArray1.length, versionArray2.length); int diff = 0; // 先比较长度，再比较字符 while (idx &lt; minLength &amp;&amp; (diff = versionArray1[idx].length() - versionArray2[idx].length()) == 0 &amp;&amp; (diff = versionArray1[idx].compareTo(versionArray2[idx])) == 0) { ++idx; } // 如果已经分出大小，则直接返回，如果未分出大小，则再比较位数，有子版本的为大 diff = (diff != 0) ? diff : versionArray1.length - versionArray2.length; return diff;} 2.算法版本不过最近发现，leetcode大神们写的算法，比较版本号。真的是简洁优雅高效，而且逻辑上更加完善。这边版本号是（忽略任何前导零后的整数值 例如1.01和1.001是一样的）。而且没有对string进行转换成数组，整体运行时间和空间都更佳。真正的简洁、优雅高效 1234567891011121314151617181920212223public int compareVersion(String version1, String version2) { if (version1 == null || version2 == null) { throw new RuntimeException(&quot;版本号不能为空&quot;); } int i = 0, j = 0; int n = version1.length(), m = version2.length(); while (i &lt; n || j &lt; m) { int a = 0; for (; i &lt; n &amp;&amp; version1.charAt(i) != '.'; i++) { a = a * 10 + version1.charAt(i) - '0'; } i++; int b = 0; for (; j &lt; m &amp;&amp; version2.charAt(j) != '.'; j++) { b = b * 10 + version2.charAt(j) - '0'; } j++; if (a != b) { return a &gt; b ? 1 : -1; } } return 0;} 3.结论看了大神们写的代码，发现和人的差距太大了。算法真的太神奇了。","link":"/2023/11/14/%E3%80%90%E7%89%88%E6%9C%AC%E5%8F%B7%E6%AF%94%E8%BE%83%E5%B7%A5%E5%85%B7-%EF%BC%88%E7%AE%97%E6%B3%95%E7%89%88%EF%BC%89%E3%80%91/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[],"pages":[]}